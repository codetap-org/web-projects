<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>p5.js + Dots Image | CodeTap</title>
  <link rel="apple-touch-icon" href="https://codetap.org/assets/img/favicon.png">
  <link rel="icon" type="image/png" href="https://codetap.org/assets/img/favicon.png">
</head>

<body>
  <html lang="en">

  <head>
    <meta charset="UTF-8" />
    <title>Force Field Magnifier</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
    <style>
      body {
        margin: 0;
        background: #000;
        color: white;
        font-family: sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        overflow: hidden;
        user-select: none;
      }

      canvas {
        display: block;
        border: 1px solid #000;
      }

      #loading {
        position: absolute;
        font-size: 10px;
        color: white;
      }
    </style>
  </head>

  <body>
    <div id="loading">Loading...</div>
    <script>
      let originalImg, img, palette = [], points = [];
      let lastHue = -1, lastSaturation = -1, lastInvertImage = null;
      let guiControllers = {};
      let magnifierX = 0, magnifierY = 0;

      let params = {
        invertWireframe: true,
        invertImage: true,
        hue: 210,
        saturation: 100,
        threshold: 255,
        minStroke: 2,
        maxStroke: 6,
        spacing: 10,
        noiseScale: 0,
        density: 2.0,
        magnifierEnabled: false,
        magnifierRadius: 150,
        magnifierStrength: 2,
        magnifierSpeed: 0.02,
        magnifierInertia: 0.1,
        forceField: {
          enabled: true,
          strength: 10,
          friction: 0.9,
          restoreSpeed: 0.05
        },
        randomize: function () {
          this.hue = Math.floor(Math.random() * 360);
          this.minStroke = parseFloat((Math.random() * 5 + 2).toFixed(1));
          this.maxStroke = parseFloat((Math.random() * 12 + 1).toFixed(1));
          this.spacing = parseFloat((Math.random() * 10 + 3).toFixed(1));
          for (let key in guiControllers) {
            guiControllers[key].updateDisplay();
          }
          generatePaletteAndPoints();
        }
      };

      document.addEventListener('dblclick', () => {
        params.randomize();
      });

      function preload() {
        originalImg = loadImage(
          "https://assets.laboutiqueofficielle.com/w_1100,q_auto,f_auto/media/products/2011/01/20/supreme-ntm_4482_ntm-stk-lyrics-blanc_20180712T071700_02.jpg",
          () => document.getElementById('loading').style.display = 'none',
          () => document.getElementById('loading').textContent = 'Failed to load image'
        );
      }

      function setup() {
        createCanvas(900, 600);
        img = originalImg.get();
        img.resize(width, height);
        img.filter(GRAY);
        generatePalette(params.hue, params.saturation);
        generatePoints();

        const gui = new dat.GUI();
        gui.close();

        const colorFolder = gui.addFolder('Color Settings');
        colorFolder.add(params, 'invertImage').name('Invert Image');
        guiControllers.hue = colorFolder.add(params, 'hue', 0, 360).step(1).name('Base Hue').onChange(generatePaletteAndPoints);
        guiControllers.saturation = colorFolder.add(params, 'saturation', 0, 100).step(1).name('Saturation').onChange(generatePaletteAndPoints);
        guiControllers.threshold = colorFolder.add(params, 'threshold', 0, 255).step(1).name('Brightness Threshold');

        const strokeFolder = gui.addFolder('Point & Stroke Settings');
        guiControllers.minStroke = strokeFolder.add(params, 'minStroke', 0.1, 3).step(0.1).name('Min Stroke Weight');
        guiControllers.maxStroke = strokeFolder.add(params, 'maxStroke', 1, 10).step(0.1).name('Max Stroke Weight');
        guiControllers.spacing = strokeFolder.add(params, 'spacing', 1, 10).step(0.5).name('Point Spacing').onChange(generatePoints);
        guiControllers.noiseScale = strokeFolder.add(params, 'noiseScale', 0, 0.1).step(0.001).name('Noise Scale').onChange(generatePoints);
        guiControllers.density = strokeFolder.add(params, 'density', 0.1, 2.0).step(0.1).name('Point Density').onChange(generatePoints);

        const magnifierFolder = gui.addFolder('Magnifier Effect');
        magnifierFolder.add(params, 'magnifierEnabled').name('Enable Magnifier');
        magnifierFolder.add(params, 'magnifierRadius', 50, 300).step(1).name('Radius');
        magnifierFolder.add(params, 'magnifierStrength', 0.1, 2).step(0.1).name('Strength');
        magnifierFolder.add(params, 'magnifierSpeed', 0.001, 1).step(0.001).name('Speed');
        magnifierFolder.add(params, 'magnifierInertia', 0, 1).step(0.01).name('Inertia');

        const forceFolder = gui.addFolder('Force Field Settings');
        forceFolder.add(params.forceField, 'enabled').name('Enable Force Field');
        forceFolder.add(params.forceField, 'strength', 0, 20).step(0.1).name('Force Strength');
        forceFolder.add(params.forceField, 'friction', 0.5, 1).step(0.01).name('Friction');
        forceFolder.add(params.forceField, 'restoreSpeed', 0.01, 0.2).step(0.01).name('Restore Speed');

        gui.add(params, 'randomize').name('Randomize - Double Click');
        magnifierX = width / 2;
        magnifierY = height / 2;
      }

      function generatePalette(hue, saturation) {
        palette = [];
        for (let i = 0; i < 12; i++) {
          let lightness = map(i, 0, 11, 95, 5);
          palette.push(color(`hsl(${hue}, ${saturation}%, ${lightness}%)`));
        }
      }

      function generatePaletteAndPoints() {
        generatePalette(params.hue, params.saturation);
        generatePoints();
      }

      function generatePoints() {
        points = [];
        let spacing = params.spacing;
        for (let y = 0; y < img.height; y += spacing) {
          for (let x = 0; x < img.width; x += spacing) {
            if (random() > params.density) continue;
            let nx = noise(x * params.noiseScale, y * params.noiseScale) - 0.5;
            let ny = noise((x + 500) * params.noiseScale, (y + 500) * params.noiseScale) - 0.5;
            let px = x + nx * spacing;
            let py = y + ny * spacing;
            points.push({
              pos: createVector(px, py),
              originalPos: createVector(px, py),
              vel: createVector(0, 0)
            });
          }
        }
      }

      function applyForceField(mx, my) {
        if (!params.forceField.enabled) return;
        for (let pt of points) {
          let dir = p5.Vector.sub(pt.pos, createVector(mx, my));
          let d = dir.mag();
          if (d < params.magnifierRadius) {
            dir.normalize();
            let force = dir.mult(params.forceField.strength / d);
            pt.vel.add(force);
          }
          pt.vel.mult(params.forceField.friction);
          let restore = p5.Vector.sub(pt.pos, pt.originalPos).mult(-params.forceField.restoreSpeed);
          pt.vel.add(restore);
          pt.pos.add(pt.vel);
        }
      }

      function draw() {
        background(0);
        if (params.hue !== lastHue || params.saturation !== lastSaturation) {
          generatePalette(params.hue, params.saturation);
          lastHue = params.hue;
          lastSaturation = params.saturation;
        }
        if (params.invertImage !== lastInvertImage) {
          img = originalImg.get();
          img.resize(width, height);
          img.filter(GRAY);
          if (params.invertImage) {
            img.loadPixels();
            for (let i = 0; i < img.pixels.length; i += 4) {
              img.pixels[i] = 255 - img.pixels[i];
              img.pixels[i + 1] = 255 - img.pixels[i + 1];
              img.pixels[i + 2] = 255 - img.pixels[i + 2];
            }
            img.updatePixels();
          }
          lastInvertImage = params.invertImage;
        }

        magnifierX = lerp(magnifierX, mouseX, params.magnifierInertia);
        magnifierY = lerp(magnifierY, mouseY, params.magnifierInertia);
        let mx = magnifierX;
        let my = magnifierY;

        applyForceField(mx, my);

        img.loadPixels();
        noFill();

        for (let pt of points) {
          let x = pt.pos.x;
          let y = pt.pos.y;
          let d = dist(x, y, mx, my);

          let px = constrain(floor(x), 0, img.width - 1);
          let py = constrain(floor(y), 0, img.height - 1);
          let index = (px + py * img.width) * 4;
          let brightness = img.pixels[index];

          let condition = params.invertWireframe
            ? brightness < params.threshold
            : brightness > params.threshold;

          if (condition) {
            let shadeIndex = int(map(brightness, 0, 255, 0, palette.length - 1));
            let strokeSize = map(brightness, 0, 255, params.minStroke, params.maxStroke);

            if (params.magnifierEnabled && d < params.magnifierRadius) {
              let factor = map(d, 0, params.magnifierRadius, params.magnifierStrength, 1);
              strokeSize *= factor;
            }

            stroke(palette[shadeIndex]);
            strokeWeight(strokeSize);
            point(x, y);
          }
        }

        // if (params.magnifierEnabled) {
        //   noFill();
        //   stroke(255, 50);
        //   strokeWeight(1);
        //   ellipse(mx, my, params.magnifierRadius * 2);
        // }
      }
    </script>
  </body>

  </html>

</body>

</html>