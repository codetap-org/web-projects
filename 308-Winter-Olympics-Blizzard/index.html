<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Winter Olympics Blizzard</title>

  <link rel="apple-touch-icon" href="https://codetap.org/assets/img/favicon.png">
  <link rel="icon" type="image/png" href="https://codetap.org/assets/img/favicon.png">
</head>

<body>
  <!DOCTYPE html>
  <html lang="en">

  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Winter Olympics - Blizzard Accumulation</title>
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
        overflow: hidden;
        background: #050a14;
      }

      canvas {
        display: block;
      }

      .ui {
        position: fixed;
        top: 20px;
        width: 100%;
        text-align: center;
        color: white;
        font-family: system-ui, sans-serif;
        letter-spacing: 6px;
        pointer-events: none;
        text-transform: uppercase;
        opacity: 0.8;
        font-weight: 300;
        text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
      }
    </style>
  </head>

  <body>
    <script>
      'use strict';

      const OLYMPIC_COLORS = ['#0081C8', '#f0f0f0', '#EE334E', '#FCB131', '#00A651'];
      const SnowflakePatternMap = { Dot: 0, Branches: 1, Spearheads: 2, Asterisk: 3 };

      class SnowflakeSprite {
        constructor(type, color) {
          this.canvas = document.createElement("canvas");
          this.ctx = this.canvas.getContext("2d");
          this.radius = 10; // Slightly smaller to accommodate more particles
          const dpr = window.devicePixelRatio || 1;
          this.canvas.width = this.radius * 2 * dpr;
          this.canvas.height = this.radius * 2 * dpr;
          this.ctx.scale(dpr, dpr);
          this.ctx.fillStyle = color;
          this.ctx.strokeStyle = color;
          this.ctx.lineWidth = 1.0;
          this.draw(type);
        }

        draw(type) {
          const ctx = this.ctx;
          const r = this.radius - 2;
          ctx.translate(this.radius, this.radius);
          if (type === SnowflakePatternMap.Dot) {
            ctx.beginPath(); ctx.arc(0, 0, r / 3, 0, Math.PI * 2); ctx.fill();
          } else {
            for (let i = 0; i < 6; i++) {
              ctx.rotate(Math.PI / 3);
              ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, -r);
              if (type === SnowflakePatternMap.Branches) {
                ctx.moveTo(0, -r * 0.4); ctx.lineTo(-r * 0.3, -r * 0.7);
                ctx.moveTo(0, -r * 0.4); ctx.lineTo(r * 0.3, -r * 0.7);
              }
              ctx.stroke();
            }
          }
        }
      }

      let w, h, canvas, ctx;
      let snowflakes = [];
      const spritesByColor = [];
      const mask = { cnv: document.createElement('canvas'), ctx: null, data: null };
      mask.ctx = mask.cnv.getContext('2d', { willReadFrequently: true });

      function init() {
        canvas = document.createElement('canvas');
        ctx = canvas.getContext('2d', { alpha: false });
        document.body.appendChild(canvas);

        OLYMPIC_COLORS.forEach(color => {
          const group = [0, 1, 2, 3].map(type => new SnowflakeSprite(type, color).canvas);
          spritesByColor.push(group);
        });

        window.addEventListener('resize', restart);
        restart();
      }

      function drawOlympicRings(targetCtx, width, height) {
        const ringR = Math.min(width, height) * 0.12;
        const thickness = ringR * 0.28; // Thicker rings for better "sticking" surface
        const centerY = height * 0.48;
        const centers = [
          { x: width / 2 - ringR * 2.3, y: centerY - ringR * 0.5 },
          { x: width / 2, y: centerY - ringR * 0.5 },
          { x: width / 2 + ringR * 2.3, y: centerY - ringR * 0.5 },
          { x: width / 2 - ringR * 1.15, y: centerY + ringR * 0.6 },
          { x: width / 2 + ringR * 1.15, y: centerY + ringR * 0.6 }
        ];

        centers.forEach((pos, i) => {
          targetCtx.strokeStyle = `rgb(${i + 1}, 0, 0)`;
          targetCtx.lineWidth = thickness;
          targetCtx.beginPath();
          targetCtx.arc(pos.x, pos.y, ringR, 0, Math.PI * 2);
          targetCtx.stroke();
        });
      }

      function buildMask() {
        mask.cnv.width = w;
        mask.cnv.height = h;
        mask.ctx.fillStyle = 'black';
        mask.ctx.fillRect(0, 0, w, h);
        drawOlympicRings(mask.ctx, w, h);
        mask.data = mask.ctx.getImageData(0, 0, w, h).data;
      }

      function restart() {
        w = window.innerWidth;
        h = window.innerHeight;
        canvas.width = w;
        canvas.height = h;
        buildMask();
        snowflakes = [];
        // Increased count to 4500 for a blizzard effect
        for (let i = 0; i < 4500; i++) {
          snowflakes.push(createSnowflake(true));
        }
        render();
      }

      function createSnowflake(initial = false) {
        const colorIdx = Math.floor(Math.random() * 5);
        return {
          x: Math.random() * w,
          y: initial ? Math.random() * h : -20,
          vx: (Math.random() - 0.5) * 2,
          vy: 1 + Math.random() * 3,
          r: 1 + Math.random() * 3.5,
          rot: Math.random() * 6,
          rv: (Math.random() - 0.5) * 0.1,
          colorIdx: colorIdx,
          sprite: spritesByColor[colorIdx][Math.floor(Math.random() * 4)],
          stuck: false,
          wind: Math.random() * 0.02
        };
      }

      function render() {
        // Trails effect disabled for performance at high particle counts, 
        // but using a solid clear for crisp snowflakes.
        ctx.fillStyle = '#050a14';
        ctx.fillRect(0, 0, w, h);

        for (let i = 0; i < snowflakes.length; i++) {
          const f = snowflakes[i];

          // Check mask
          const pixelIdx = (Math.floor(f.x) + Math.floor(f.y) * w) * 4;
          const ringId = mask.data[pixelIdx];

          if (ringId > 0) {
            const targetColorIdx = ringId - 1;
            f.vx *= 0.82; // Increased friction for stickier feel
            f.vy *= 0.82;
            f.vy += 0.04;

            if (f.colorIdx !== targetColorIdx) {
              f.colorIdx = targetColorIdx;
              f.sprite = spritesByColor[targetColorIdx][Math.floor(Math.random() * 4)];
            }
            f.stuck = true;
          } else {
            f.vx += f.wind; // Subtle wind drift
            f.vy += 0.03;
            if (f.vy > 3.5) f.vy = 3.5;
            f.stuck = false;
          }

          f.x += f.vx;
          f.y += f.vy;
          f.rot += f.rv;

          // Boundary reset
          if (f.y > h + 10 || f.x > w + 10 || f.x < -10) {
            // Re-use object instead of creating new one
            const newData = createSnowflake(false);
            Object.assign(f, newData);
          }

          ctx.save();
          ctx.translate(f.x, f.y);
          ctx.rotate(f.rot);
          ctx.globalAlpha = f.stuck ? 1.0 : 0.35;
          ctx.drawImage(f.sprite, -f.r, -f.r, f.r * 2, f.r * 2);
          ctx.restore();
        }

        requestAnimationFrame(render);
      }

      init();
    </script>
  </body>

  </html>

</body>

</html>